---
lang: "java"
title: "Construct Binary Tree from Preorder and Inorder Traversal"
slug: "construct-binary-tree-from-preorder-and-inorder-traversal"
author: "Swaroop"
date: "Saturday, 2 April 2022"
---
```java
class Solution {
   // for getting the roots one by one in preorder
    int preorderIndex = 0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(preorder, inorder, 0, preorder.length-1);
    }
    TreeNode helper(int[] pre, int[] in, int s,int e){
        if(s > e) return null;
        // getting the pos of root (i.e using preorderIndex in preorder array) in inorder array gives its left and right subtree
        int inorderIndex = find(in,s,e,pre[preorderIndex]);
        TreeNode root = new TreeNode(pre[preorderIndex]);
        // for next root in preorder
        preorderIndex++;
       // left subtree
        root.left = helper(pre,in,s,inorderIndex-1);
       // right subtree
        root.right = helper(pre,in,inorderIndex+1,e);
        return root;
    }
    int find(int[] arr, int s, int e, int key){
        int i=s;
        for(;i<=e;i++){
            if(arr[i] == key) break;
        }
        return i;
    }
}

// printing postorder using preorder and inorder traversal
class Solution {
    int preorderIndex = 0;
    public void printPreorder(int[] preorder, int[] inorder) {
        helper(preorder, inorder, 0, preorder.length-1);
    }
    void helper(int[] pre, int[] in, int s,int e){
        if(s > e) return;
        int inorderIndex = find(in,s,e,pre[preorderIndex]);
        int cur = pre[preorderIndex]);
        preorderIndex++;
        helper(pre,in,s,inorderIndex-1);
        helper(pre,in,inorderIndex+1,e);
        print(curr);
    }
    int find(int[] arr, int s, int e, int key){
        int i=s;
        for(;i<=e;i++){
            if(arr[i] == key) break;
        }
        return i;
    }
}
```